**Free
       ctl-opt nomain;
      /COPY ARPG_H,ARCALLCTL
      //---------------------------------------------------------------*
      // extern prototypes
      //---------------------------------------------------------------*
      /COPY ARPG_H,ARCJMSR
      /COPY ARPG_H,ARCSTRING

      //---------------------------------------------------------------*
      // constants
      //---------------------------------------------------------------*

      //---------------------------------------------------------------
      // typedef
      //---------------------------------------------------------------
       dcl-ds JmsMessage_t template qualified;
         JmsProp int(10) inz(-1);
         BodyCcsid int(10) inz(CCSID_BINARY);
         BodyLen int(10) inz(0);
         BodyData pointer inz(*Null);            
       end-ds;  
       
       dcl-ds JmsPropKey_t template qualified;
         Folder varchar(20) inz('');
         Name varchar(100) inz('');
       end-ds;  

       dcl-ds JmsProperty_t template qualified;
         key  likeds(JmsPropKey_t);
         type varchar(10) inz('');
         data varchar(65535) inz('');
       end-ds;  

      //---------------------------------------------------------------
      // JmsNew
      //---------------------------------------------------------------
      //* Erstellen einer neun JMS Nachricht oder Parsen der übergebenen
      //* Nachricht.
      //* <P>
      //*
      //* @param PPtMsg - JMS/RFH Nachricht (optional).
      //*
      //* @return Handle der Nachricht, sonst -1.
      //*
      //* @see https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_7.1.0/com.ibm.mq.doc/ir13130_.htm
      //* 
      //* @author S.Allbach
      //---------------------------------------------------------------
       dcl-proc JmsNew export;
         dcl-pi *N int(10);
           PPtMessage pointer const options(*nopass);
         end-pi;

         dcl-s inMsg int(10);
         dcl-s ptMsg pointer;
         dcl-ds dsMsg likeds(JmsMessage_t) based(ptMsg) end-ds;

         // leeres Objekt erstellen
         PInMsg = OoRObjectNew(S#Prog:PPtMsg:%size(PDsMsg));

         // Init
         clear PDsMsg;
         PDsMsg.JmsProp = MapNew();

         // nur leere Nachricht ?
         if %parms() < %parmnum(PPtMsg);
           return PInMsg;
         endif;

         // @todo 
         // Wurde PPtMsg übergebn muss die Nachricht geparsed weden ...
         // Achtung ByteOrder beachten und bei Bedarf drehen
         // XML-SAX für die einzelnen Folder nach PDsMsg.JmsProp (siehe SrvCmI(?) oder srvcmc)
         // ccsid (RF2NVC) des Kopfes(xml) muss an den Parser gegeben werden - ist nicht immer CCSID_UTF8
         // https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_7.1.0/com.ibm.mq.doc/ir13130_.htm

         return PInMsg;

       end-proc JmsNew...
      //---------------------------------------------------------------
      // JmsFree
      //---------------------------------------------------------------
      //* JMS Nachricht freigeben.
      //* <P>
      //*
      //* @param PInMsg - Handle der Nachricht @link #JmsNew
      //*
      //* @return 0 - Handle erfolgreich gelöscht, sonst -1.
      //*
      //* @author S.Allbach
      //---------------------------------------------------------------
       dcl-proc JmsFree export;
         dcl-pi *N int(10);
           inMsg int(10) const;
         end-pi;

         dcl-s ptMsg pointer;
         dcl-ds dsMsg likeds(JmsMessage_t) based(ptMsg) end-ds;

         // Zeiger laden
         PPtMsg = HandleGet(S#Prog:PInMsg);
         if PPtMsg = *Null;
           MhSndPM(ExpExcp:ExpExcpM:ExpExcpA:
                      %size(ExpExcpA):API_DIAG:'*':1:ExpMKey:QUsecF);
           return -1;
         endif;

         MapFree(PDsMsg.JmsProp);
         JmsClearBody(PInMsg);
         dealloc PPtMsg;

         return 0;

       end-proc JmsFree;
      //---------------------------------------------------------------
      // JmsIsValid
      //---------------------------------------------------------------
      //* Prüft ob der übergebene Handle ein gültiger JMS Nachrichten Handle ist.
      //* <P>
      //*
      //* @param PInMsg - Handle der Nachricht @link #JmsNew
      //*
      //* @return *on - Handle ist noch gültig
      //* @return *off - Handle ist ungültig
      //*
      //* @author S.Allbach
      //---------------------------------------------------------------
       dcl-proc JmsIsValid export;
         dcl-pi *N ind;
           inMsg int(10) const;
         end-pi;

         dcl-s ptMsg pointer;
         dcl-ds dsMsg likeds(JmsMessage_t) based(ptMsg) end-ds;

         return (HandleGet(S#Prog:PInMsg) <> *Null);

       end-proc JmsIsValid;
      //---------------------------------------------------------------
      // JmsClearBody
      //---------------------------------------------------------------
      //* JMS NachrichtenBody bereinigen.
      //* <P>
      //*
      //* @param PInMsg - Handle der Nachricht @link #JmsNew
      //*
      //* @return 0 - erfolgreich, sonst -1.
      //*
      //* @author S.Allbach
      //---------------------------------------------------------------
       dcl-proc JmsClearBody export;
         dcl-pi *N int(10);
           inMsg int(10) const;
         end-pi;

         dcl-s ptMsg pointer;
         dcl-ds dsMsg likeds(JmsMessage_t) based(ptMsg) end-ds;

         // Zeiger laden
         PPtMsg = HandleGet(S#Prog:PInMsg);
         if PPtMsg = *Null;
           MhSndPM(ExpExcp:ExpExcpM:ExpExcpA:
                      %size(ExpExcpA):API_DIAG:'*':1:ExpMKey:QUsecF);
           return -1;
         endif;

         _C_Free(PDsMsg.BodyData);
         PDsMsg.BodyCcsid = CCSID_BINARY;
         PDsMsg.BodyLen = 0;
         return 0;

       end-proc JmsClearBody;
      //---------------------------------------------------------------
      // JmsClearProperties
      //---------------------------------------------------------------
      //* JMS Nachrichteneigenschaften bereinigen.
      //* <P>
      //*
      //* @param PInMsg - Handle der Nachricht @link #JmsNew
      //*
      //* @return 0 - erfolgreich, sonst -1.
      //*
      //* @author S.Allbach
      //---------------------------------------------------------------
       dcl-proc JmsClearProperties export;
         dcl-pi *N int(10);
           inMsg int(10) const;
         end-pi;

         dcl-s ptMsg pointer;
         dcl-ds dsMsg likeds(JmsMessage_t) based(ptMsg) end-ds;

         // Zeiger laden
         PPtMsg = HandleGet(S#Prog:PInMsg);
         if PPtMsg = *Null;
           MhSndPM(ExpExcp:ExpExcpM:ExpExcpA:
                      %size(ExpExcpA):API_DIAG:'*':1:ExpMKey:QUsecF);
           return -1;
         endif;

         MapClear(PDsMsg.JmsProp);
         return 0;

       end-proc JmsClearProperties;
      //---------------------------------------------------------------
      // JmsGetBodyString
      //---------------------------------------------------------------
      //* JMS Nachrichtenkörper als String lesen (in der Job CCSID).
      //* <P>
      //*
      //* @param PInMsg - Handle der Nachricht @link #JmsNew
      //*
      //* @return Nachricht in der Ccsid des Jobs. (Max 16MB)
      //*
      //* @author S.Allbach
      //---------------------------------------------------------------
       dcl-proc JmsGetBodyString export;
         dcl-pi *N varchar(16M) rtnparm;
           inMsg int(10) const;
         end-pi;
         
     d PPtStr          s               *
     d PAnRes          s                   varying len(16M)
         dcl-s ptMsg pointer;
         dcl-ds dsMsg likeds(JmsMessage_t) based(ptMsg) end-ds;

         // Zeiger laden
         PPtMsg = HandleGet(S#Prog:PInMsg);
         if PPtMsg = *Null;
           MhSndPM(ExpExcp:ExpExcpM:ExpExcpA:
                      %size(ExpExcpA):API_DIAG:'*':1:ExpMKey:QUsecF);
           return -1;
         endif;

         PPtRes = StrIconv(PDsMsg.BodyData:PDsMsg.BodyLen:PDsMsg.BodyCcsid:CCSID_JOB:PInLen)??
         if PPtRes = *Null;
           return *Null;
         endif;

         if PInLen > %len(PAnData:*maxsize);
           // @todo Fehlermeldung
           MhSndPM('DZP1???:DZPMSGF:ExpExcpA
                   :MsgFmtMsg('DZP1???)
                   :%size(ExpExcpA):API_ESCAPE:'*':1:ExpMKey:QUsecF);
           // EXIT
         endif;

         PAnRes = %str(PPtRes:PInLen);
         _C_Free(PPtRes);

         return PAnRes;

       end-proc JmsGetBodyString;
      //---------------------------------------------------------------
      // JmsGetBody
      //---------------------------------------------------------------
      //* JMS Nachrichtenkörper lesen.
      //* <P>
      //*
      //* @param PInMsg - Handle der Nachricht @link #JmsNew
      //* @param PInLen - Rückgabe der Länge der Nachricht
      //*
      //* @return Zeiger auf die Nachricht, sonst *Null.
      //*
      //* @author S.Allbach
      //---------------------------------------------------------------
       dcl-proc JmsGetBody export;
         dcl-pi *N pointer;
           inMsg int(10) const;
           inLen like(size_t);
         end-pi;

         dcl-s ptMsg pointer;
         dcl-ds dsMsg likeds(JmsMessage_t) based(ptMsg) end-ds;

         // Zeiger laden
         PPtMsg = HandleGet(S#Prog:PInMsg);
         if PPtMsg = *Null;
           MhSndPM(ExpExcp:ExpExcpM:ExpExcpA:
                      %size(ExpExcpA):API_DIAG:'*':1:ExpMKey:QUsecF);
           return -1;
         endif;

         PInLen = PDsMsg.BodyLen;

         return PDsMsg.BodyData;

       end-proc JmsGetBody;
      //---------------------------------------------------------------
      // JmsGetBodyFile
      //---------------------------------------------------------------
      //* JMS Nachrichtenkörpers als Datei im IFS speichern.
      //* <P>
      //* Die Ccsid der Datei wir auf die des NachrichtenBodies gesetzt.
      //*
      //* @param PInMsg - Handle der Nachricht @link #JmsNew
      //* @param PAnFile - Dateiname zum Speicher der Daten. 
      //*
      //* @return 0 - Datei erfolgreich geschrieben, sonst -1.
      //*
      //* @author S.Allbach
      //---------------------------------------------------------------
       dcl-proc JmsGetBodyFile export;
         dcl-pi *N int(10);
           inMsg int(10) const;
           ptFile pointer options(*string);
         end-pi;
         
         dcl-s ptMsg pointer;
         dcl-ds dsMsg likeds(JmsMessage_t) based(ptMsg) end-ds;

         // Zeiger laden
         PPtMsg = HandleGet(S#Prog:PInMsg);
         if PPtMsg = *Null;
           MhSndPM(ExpExcp:ExpExcpM:ExpExcpA:
                      %size(ExpExcpA):API_DIAG:'*':1:ExpMKey:QUsecF);
           return -1;
         endif;

         PInFile = OpenFile(PAnFile:create binary)
         if PInFile = -1;
           MhSndPM(ExpExcp:ExpExcpM:ExpExcpA:
                      %size(ExpExcpA):API_DIAG:'*':1:ExpMKey:QUsecF);
           return -1;
         endif;

         if IfsWriteFile(PInFile:PDsMsg.BodyData:PDsMsg.BodyLen) <> PDsMsg.BodyLen;
           MhSndPM(ExpExcp:ExpExcpM:ExpExcpA:
                      %size(ExpExcpA):API_DIAG:'*':1:ExpMKey:QUsecF);
           CloseFile(PInFile);
           Unlink(PAnFile);
           return -1;
         endif;
 
         if CloseFile(PInFile) = -1;
           MhSndPM(ExpExcp:ExpExcpM:ExpExcpA:
                      %size(ExpExcpA):API_DIAG:'*':1:ExpMKey:QUsecF);
           return -1;
         endif;

         IfsSetCssid(PAnFile:PDsMsg.BodyCcsid);

         return 0;

       end-proc JmsGetBodyFile;
      //---------------------------------------------------------------
      // JmsGetBodyCcsid
      //---------------------------------------------------------------
      //* Ccsid des JMS Nachrichtenkörpers.
      //* <P>
      //*
      //* @param PInMsg - Handle der Nachricht @link #JmsNew
      //*
      //* @return Gibt die Ccsid des Nachrichtenkörpers zurück, sonst 65535(binary)
      //*
      //* @author S.Allbach
      //---------------------------------------------------------------
       dcl-proc JmsGetBodyCcsid export;
         dcl-pi *N int(10);
           inMsg int(10) const;
         end-pi;
         
         dcl-s ptMsg pointer;
         dcl-ds dsMsg likeds(JmsMessage_t) based(ptMsg) end-ds;

         // Zeiger laden
         PPtMsg = HandleGet(S#Prog:PInMsg);
         if PPtMsg = *Null;
           MhSndPM(ExpExcp:ExpExcpM:ExpExcpA:
                      %size(ExpExcpA):API_DIAG:'*':1:ExpMKey:QUsecF);
           return CCSID_BINARY;
         endif;

         return PDsMsg.Ccsid;

       end-proc JmsGetBodyCcsid;
      //---------------------------------------------------------------
      // JmsSetBody
      //---------------------------------------------------------------
      //* JMS NachrichtenBody schreiben.
      //* <P>
      //*
      //* @param PInMsg - Handle der Nachricht @link #JmsNew
      //* @param PPtData - Daten als Pointer oder String
      //* @param PInLen - Länge der Nachricht (optional)
      //* @param PInCcsid - Ccsid der übergebenen Daten (optional - Default @const CCSID_JOB).
      //*
      //* @return 0 - Erfolgreich, sonst -1
      //*
      //* @author S.Allbach
      //---------------------------------------------------------------
       dcl-proc JmsSetBody export;
         dcl-pi *N int(10);
           inMsg int(10) const;
           ptData pointer options(*string);
           inLen like(size_t) const options(*omit:*nopass);
           inCcsid int(10) const options(*omit:*nopass);
         end-pi;
         
     d PInLen_         s                   like(size_t) inz(0)
     d PInCcsid_       s             10I 0 inz(CCSID_JOB)
         dcl-s ptMsg pointer;
         dcl-ds dsMsg likeds(JmsMessage_t) based(ptMsg) end-ds;

         // Zeiger laden
         PPtMsg = HandleGet(S#Prog:PInMsg);
         if PPtMsg = *Null;
           MhSndPM(ExpExcp:ExpExcpM:ExpExcpA:
                      %size(ExpExcpA):API_DIAG:'*':1:ExpMKey:QUsecF);
           return -1;
         endif;
 
         if %parms() >= %parmnum(PInLen) And 
              %addr(PInLen) <> *Null And PInLen > 0;
           PInLen_ = PInLen;
         endif;
       
         if %parms() >= %parmnum(PInCcsid) And 
              %addr(PInCcsid) <> *Null;
           PInCcsid_ = PInCcsid;
         endif;

         JmsClearBody(PInMsg);
         PDsMsg.BodyLen = PInLen_;
         if PInLen_ = *Zeros;
           PDsMsg.BodyLen = Strlen(PPtData);
         endif;

         if PInLen_ = *Zeros;
           return 0;
         endif;

         PDsMsg.BodyData = _C_malloc(PDsMsg.BodyLen);

         MemCpy(PDsMsg.BodyData:PPtData:PDsMsg.BodyData);

         return 0;

       end-proc JmsSetBody;
      //---------------------------------------------------------------
      // JmsGetJmsMessage
      //---------------------------------------------------------------
      //* Gibt die JMS Nachricht zurück, so dass sie mit MQ
      //* gesendet werden kann.
      //* <P>
      //*
      //* @param PInMsg - Handle der Nachricht @link #JmsNew
      //* @param PInLen - Größe der Nachricht
      //*
      //* @return Zeiger auf die Nachricht. Dieser muss durch den Aufrufer
      //*         mit _C_Free wieder dealloziert werden
      //*
      //* @author S.Allbach
      //---------------------------------------------------------------
       dcl-proc JmsGetJmsMessage export;
         dcl-pi *N pointer;
           inMsg int(10) const;
           inLen like(size_t);
           inCcsid int(10) options(*omit:*nopass);
         end-pi;
         
     d PPtData         s               *   inz(*Null)
         dcl-s ptMsg pointer;
         dcl-ds dsMsg likeds(JmsMessage_t) based(ptMsg) end-ds;

         // Zeiger laden
         PPtMsg = HandleGet(S#Prog:PInMsg);
         if PPtMsg = *Null;
           MhSndPM(ExpExcp:ExpExcpM:ExpExcpA:
                      %size(ExpExcpA):API_DIAG:'*':1:ExpMKey:QUsecF);
           return *Null;
         endif;

         // @todo
         // Baut die Nachricht in diesem Format :
         // https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_7.1.0/com.ibm.mq.doc/ir13130_.htm
         // ccsid (RF2NVC) des Kopfes(xml) immer CCSID_UTF8
         // ccsid (RF2CSI) = DataCcsid und ist diese CCSID_JOB (0) dann die vom Job 
         // wenn nicht CCSID_BINARY dann RF2FMT = FMSTR sonst FMNONE

         return PPtData;

       end-proc JmsGetJmsMessage;
      //---------------------------------------------------------------
      // JmsSend
      //---------------------------------------------------------------
      //* Sendet die Nachricht an die übergebene Verbindung.
      //* <P>
      //*
      //* @param PInMsg - Handle der Nachricht @link #JmsNew
      //* @param PInCon - Connection @link SrvMqcr.SrvMqcr.MqsOpen 
      //*
      //* @return 0 - Erfolgreich, sonst -1
      //*
      //* @author S.Allbach
      //---------------------------------------------------------------
       dcl-proc JmsSend export;
         dcl-pi *N int(10);
           inMsg int(10) const;
           inCon int(10) const;
         end-pi;

     d PPtData         s               *
     d PInLen          s                   like(size_t)
         dcl-s ptMsg pointer;
         dcl-ds dsMsg likeds(JmsMessage_t) based(ptMsg) end-ds;

         // Zeiger laden
         PPtMsg = HandleGet(S#Prog:PInMsg);
         if PPtMsg = *Null;
           MhSndPM(ExpExcp:ExpExcpM:ExpExcpA:
                      %size(ExpExcpA):API_DIAG:'*':1:ExpMKey:QUsecF);
           return -1;
         endif;

         PPtData = JmsGetJmsMessage(PInMsg:PInLen);  
         if PPtData = *Null;
           // @todo Fehlermeldung
           return -1;
         endif;

         if MqsPutStringIfs(PInCon:PPtData:PInLen) = -1;
           // @todo Fehlermeldung
           _C_Free(PPtData);
           return -1;
         endif;

         _C_Free(PPtData);

         return 0;

       end-proc JmsSend;
      //---------------------------------------------------------------
      // JmsReceive
      //---------------------------------------------------------------
      //* Empfängt eine Nachricht von der übergebene Verbindung.
      //* <P>
      //*
      //* @param PInCon - Connection @link SrvMqcr.SrvMqcr.MqsOpen oder
      //*                 @link SrvMqcr.SrvMqc??.MqsSubscribe
      //*
      //* @return >0 - Einen gültigen Nachrichtenhandle @link #JmsNew
      //* @return 0 - Keine Nachricht gelesen
      //* @return -1 - Fehler
      //*
      //* @author S.Allbach
      //---------------------------------------------------------------
       dcl-proc JmsReceive export;
         dcl-pi *N int(10);
           inCon int(10) const;
         end-pi;

     d PPtData         s               *
         dcl-s ptMsg pointer;
         dcl-ds dsMsg likeds(JmsMessage_t) based(ptMsg) end-ds;

         if MqsGetStringIfs(PInCon:PPtData:PInLen) = -1; ????
           // @todo Fehlermeldung
           return -1;
         endif;

         PInMsg = JmsNew(PPtData);
         if PInMsg = -1;
           // @todo Fehlermeldung
         endif;

         _C_Free(PPtData);
         return PInMsg;

       end-proc JmsReceive;
      //---------------------------------------------------------------
      // JmsGetProperty
      //---------------------------------------------------------------
      //* Gibt eine Eigenschaft aus einem Folder zurück
      //* <P>
      //* Nur zur internen Nutzung.
      //*
      //* @param PInMsg - Handle der Nachricht @link #JmsNew
      //* @param PAnFolder - Name des folders (@const JMS_FOLDER_MCD, 
      //*                                      @const JMS_FOLDER_JMS,
      //*                                      @const JMS_FOLDER_USR,
      //*                                      @const JMS_FOLDER_MQPS)
      //* @param PAnName - Name der Eigenschaft
      //* @param PAnType - Datentyp (@const JMS_FOLDER_MCD, 
      //*                                      @const JMS_FOLDER_JMS,
      //*                                      @const JMS_FOLDER_USR,
      //*                                      @const JMS_FOLDER_MQPS)
      //* @param PAnData - Daten
      //*
      //* @return 0 - Erfolgreich, sonst -1
      //*
      //* !! PROTECTED !!
      //*
      //* @author S.Allbach
      //---------------------------------------------------------------
       dcl-proc JmsGetProperty export;
         dcl-pi *N int(10);
           inMsg int(10) const;
           anFolder varchar(20) const;
           anName varchar(100) const;
           anType varchar(10);
           anData varchar(65535);
         end-pi;

         dcl-s ptMsg pointer;
         dcl-ds dsMsg likeds(JmsMessage_t) based(ptMsg) end-ds;
     d PDsProp         ds                  likeds(JmsProperty_t)

         // Zeiger laden
         PPtMsg = HandleGet(S#Prog:PInMsg);
         if PPtMsg = *Null;
           MhSndPM(ExpExcp:ExpExcpM:ExpExcpA:
                      %size(ExpExcpA):API_DIAG:'*':1:ExpMKey:QUsecF);
           return -1;
         endif;

         PDsProp.key.folder = PAnFolder;
         PDsProp.key.name = PAnName;

         PDsProp = MapGet(PDsMsg.JmsProp:PDsProp.key);

         PAnType = '';
         PAnData = '';

         if PDsProp.key.name <> PAnName;
           // @todo Fehlermeldung
           return -1;
         endif;

         PAnType = PDsProp.type;
         PAnData = PDsProp.data;

         return 0;

       end-proc JmsGetProperty;
      //---------------------------------------------------------------
      // JmsSetProperty
      //---------------------------------------------------------------
      //* Setzt eine Eigenschaft in einem Folder      
      //* <P>
      //* Nur zur internen Nutzung.
      //*
      //* @param PInMsg - Handle der Nachricht @link #JmsNew
      //* @param PAnFolder - Name des folders (@const JMS_FOLDER_MCD, 
      //*                                      @const JMS_FOLDER_JMS,
      //*                                      @const JMS_FOLDER_USR,
      //*                                      @const JMS_FOLDER_MQPS)
      //* @param PAnName - Name der Eigenschaft
      //* @param PAnType - Datentyp (@const JMS_TYPE_STRING, 
      //*                            @const JMS_TYPE_BINHEX,
      //*                            @const JMS_TYPE_I1,
      //*                            @const JMS_TYPE_I2,
      //*                            @const JMS_TYPE_I4,
      //*                            @const JMS_TYPE_I8,
      //*                            @const JMS_TYPE_INT,
      //*                            @const JMS_TYPE_R4,
      //*                            @const JMS_TYPE_R8)
      //* @param PAnData - Daten
      //*
      //* @return 0 - Erfolgreich, sonst -1
      //*
      //* !! PROTECTED !!
      //*
      //* @author S.Allbach
      //---------------------------------------------------------------
       dcl-proc JmsSetProperty export;
         dcl-pi *N int(10);
           inMsg int(10) const;
           anFolder varchar(20) const;
           anName varchar(100) const;
           anType varchar(10) const;
           anData varchar(65535) const;
         end-pi;

         dcl-s ptMsg pointer;
         dcl-ds dsMsg likeds(JmsMessage_t) based(ptMsg) end-ds;
     d PDsProp         ds                  likeds(JmsProperty_t)

         // Zeiger laden
         PPtMsg = HandleGet(S#Prog:PInMsg);
         if PPtMsg = *Null;
           MhSndPM(ExpExcp:ExpExcpM:ExpExcpA:
                      %size(ExpExcpA):API_DIAG:'*':1:ExpMKey:QUsecF);
           return -1;
         endif;

         if PDsProp.key.folder = *blanks or
              PDsProp.key.name = *blanks;
           // @todo Fehlermeldung
           return -1;
         endif;

         PDsProp.key.folder = PAnFolder;
         PDsProp.key.name = PAnName;
         PDsProp.type = PAnType;
         PDsProp.data = PAnData;

         return MapPut(PDsMsg.JmsProp
                         :PDsProp.key
                         :PDsProp
                         :%size(PDsProp)  // etwas Speicher sparen...
                          - %len(PDsProp.data:*max) 
                          + %len(PDsProp.data));

       end-proc JmsSetProperty;
