**Free
ctl-opt nomain;
ctl-opt ccsid(*ucs2:13488);
/COPY ARPG_H,ARCALLCTL
//---------------------------------------------------------------*
// includes
//---------------------------------------------------------------*
/DEFINE AR_QSQPRC_SQLCA__
/COPY ARPG_H,ARCSYSR
/COPY ARPG_H,ARCSQLR
/COPY ARPG_H,ARCOORR
/COPY ARPG_H,ARCSYSR
/COPY ARPG_H,ARCFCNTL
/COPY ARPG_H,ARCQSQPRC
/COPY ARPG_H,ARCSTDLIB
/COPY ARPG_H,ARCSTRING

//---------------------------------------------------------------*
// typedefs
//---------------------------------------------------------------*
dcl-ds DsResultSet_t qualified align(*full) template;
  inSqlVarOccur int(10) inz(0);
  inFields int(10) inz(0);
  RelatedStatement int(10) inz(0);
  ptResultDa pointer inz(*null); // SqlDa
  ptSqlVars pointer inz(*null); 
  ptData pointer inz(*null); // Data
  ptInd pointer inz(*null); // Indicators
  SqPrcEd likeds(DsSqPrcEd_t);
  boLobAsString ind;
end-ds;

//---------------------------------------------------------------*
// constants
//---------------------------------------------------------------*
dcl-c SQL_NUM 1; // see AR_QSQPRC_SQLCA__

//---------------------------------------------------------------*
// global
//---------------------------------------------------------------*
dcl-s gPtSqlVar pointer;
dcl-ds gDsSqlVar qualified based(gPtSqlVar) align(*full);
  SqlType int(10);
  SqlTypeOrig int(10);
  SqlPrecision int(10);
  SqlScale int(10);
  SqlLen int(10);
  SqlBytes int(10);
  SqlData pointer;
  SqlInd pointer;
  SqlLob int(20);
  SqlFile int(10);
  SqlCcsid int(10);
  SqlIndVal int(10);
  SqlIsNull ind;
  SqlHasError ind;
  SqlSysName varchar(30);
  SqlLongName varchar(30);
  SqlText varchar(30);
end-ds; 

dcl-s gPtResultSet pointer inz(*Null);
dcl-ds gDsResultSet likeds(DsResultSet_t) based(gPtResultSet); 

//---------------------------------------------------------------*
//  SqlResultSetNew - protected
//---------------------------------------------------------------*
//* Create a new result set.  
//*
//* @param pDsSqPrcEd - Statement settings
//* @param pPtOpenDa - Open data area
//* @param pPtDescribeDa - Description data area
//*
//* @return A result set
//* @return -1 - Error
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetNew export;
  dcl-pi *N int(10);
    pDsSqPrcEd likeds(DsSqPrcEd_t) const;
    pPtOpenDa pointer;
    pPtDescribeDa pointer;
    pBoLobAsString ind const;
  end-pi;

  dcl-s pInResultSet int(10);
  dcl-s pPtResultSet pointer inz(*Null);
  dcl-ds pDsResultSet likeds(DsResultSet_t) based(pPtResultSet); 

  dcl-ds pDsDescribeDa likeds(SqlDa) based(pPtDescribeDa);

  dcl-s pPtResultDa pointer;
  dcl-ds pDsResultDa likeds(SqlDa) based(pPtResultDa);
  dcl-ds pDsOpenDa likeds(SqlDa) based(pPtOpenDa);

  dcl-s pPtSqlVar pointer;
  dcl-ds pDsSqlVar likeds(SqlVar) based(pPtSqlVar);

  dcl-s pInAlloc int(10) inz(0);
  dcl-s pInPrevious int(10) inz(0);
  dcl-s i int(10);

  // New result object
  pInResultSet = OoRObjectNew(s#Prog:pPtResultSet:%size(DsResultSet_t));
  if pInResultSet = -1;
    return -1;
  endif;
  clear pDsResultSet;
  pDsResultSet.boLobAsString = pBoLobAsString;
  
  // save prepared statement 
  pPtResultDa = %alloc(pDsDescribeDa.SQLDABC);
  memcpy(pPtResultDa:pPtDescribeDa:pDsDescribeDa.SQLDABC);
  pDsResultSet.ptResultDa = pPtResultDa;
  pDsResultSet.SqPrcEd = pDsSqPrcEd;

  // more SQL_VARs per field
  pDsResultSet.inSqlVarOccur = 1;
  if %subst(pDsResultDa.SQLDAID:7:1) <> *blanks;
    pDsResultSet.inSqlVarOccur = %dec(%subst(pDsResultDa.SQLDAID:7:1):1:0);
  endif;

  pDsResultSet.ptSqlVars =  %alloc(%size(gDsSqlVar) * pDsResultDa.SQLD); 
  pDsResultSet.inFields = pDsResultDa.SQLD;

  // calculate storage
  for i=1 by 1 to pDsResultDa.SQLD;
    gPtSqlVar = pDsResultSet.ptSqlVars + %size(gDsSqlVar) * (i-1); 
    SqlFillSqlVar(pPtResultDa:i
                 :pDsResultSet.inSqlVarOccur
                 :pDsResultDa.SQLD
                 :pDsResultSet.boLobAsString);    
    pInAlloc += gDsSqlVar.SqlBytes;
  endfor; 
  
  // allocate storage
  pDsResultSet.ptData = %alloc(pInAlloc * pDsSqPrcEd.blocking); 
  pDsResultSet.ptInd = %alloc(2 * pDsResultDa.SQLD * pDsSqPrcEd.blocking); 
   
  // set storage
  for i=0 by 1 to pDsResultDa.SQLD-1;
    pPtSqlVar = %Addr(pDsResultDa.Sql_Var(1)) + %size(SQLVAR) * i; 
    pDsSqlVar.SqlData = pDsResultSet.ptData + pInPrevious;
    pDsSqlVar.SqlInd = pDsResultSet.ptInd + 2 * i; 
    gPtSqlVar = pDsResultSet.ptSqlVars + %size(gDsSqlVar) * i; 
    gDsSqlVar.SqlData = pDsSqlVar.SqlData;
    gDsSqlVar.SqlInd = pDsSqlVar.SqlInd; 
    pInPrevious += gDsSqlVar.SqlBytes;
  endfor; 
  
  pDsResultSet.SqPrcEd.openopt = SQL_OPEN_READ; 
  pDsResultSet.SqPrcEd.function = SQL_FUNCTION_OPEN;
  pDsResultSet.SqPrcEd.cursorname = 'ARSCUR_' + %char(pInResultSet);
  
  Q_SqPrcEd(SqlCa:pDsOpenDa:'SQLP0400':pDsResultSet.SqPrcEd:QUSecExcp);
  
  if SqlCode <> 0;
    // todo message
    SqlResultSetClose(pInResultSet);
    return -1;
  endif;
  
  return pInResultSet;

end-proc SqlResultSetNew;
//---------------------------------------------------------------*
//  SqlResultSetSetRelatedStatement - protected
//---------------------------------------------------------------*
//* Will close the given Statement with the result set.  
//*
//* @param pInResultSet int(10) const;
//* @param pInPrepStm int(10) const;
//*
//* @return A result set
//* @return -1 - Error
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetSetRelatedStatement export;
  dcl-pi *N int(10);
    pInResultSet int(10) const;
    pInPrepStm int(10) const;
  end-pi;
 
  dcl-s pPtResultSet pointer inz(*Null);
  dcl-ds pDsResultSet likeds(DsResultSet_t) based(pPtResultSet); 

  pPtResultSet = OoRObjectGet(s#prog:pInResultSet);
  if pPtResultSet = *Null;
    // todo message
    return -1;
  endif;

  PDsResultSet.RelatedStatement = pInPrepStm;
  
  return 0;

end-proc SqlResultSetSetRelatedStatement;
//---------------------------------------------------------------*
//  SqlResultSetNext
//---------------------------------------------------------------*
//* Moves the cursor forward one row from its current position.
//+ 
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//*
//* @return *on - if the new current row is valid
//* @return *off - if there are no more rows
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetNext export;
  dcl-pi *N ind;
    pInResultSet int(10) const;
  end-pi;

  dcl-s pPtResultSet pointer inz(*Null);
  dcl-ds pDsResultSet likeds(DsResultSet_t) based(pPtResultSet); 

  dcl-s pPtResultDa pointer;
  dcl-ds pDsResultDa likeds(SqlDa) based(pPtResultDa);

  pPtResultSet = OoRObjectGet(s#prog:pInResultSet);
  if pPtResultSet = *Null;
    // todo message
    // TODO Exception ?
    return *off;
  endif;

  pPtResultDa = pDsResultSet.ptResultDa;
  pDsResultSet.SqPrcEd.function = SQL_FUNCTION_FETCH;
  pDsResultSet.SqPrcEd.position = SQL_FETCH_NEXT;
  
  Q_SqPrcEd(SqlCa:pDsResultDa:'SQLP0400':pDsResultSet.SqPrcEd:QUSecExcp);

  if SqlCode <> 0 and SqlCode <> SQL_CODE_EOF; 
    // todo message
    // TODO Exception ?
    return *off;
  endif;
  
  if SqlCode = SQL_CODE_EOF;
    if pDsResultSet.SqPrcEd.scroll = SQL_CURSOR_SCROLLABLE_NO;
      SqlResultSetClose(pInResultSet);
    endif;
    return *off;
  endif;  
  
  return *on;

end-proc SqlResultSetNext;
//---------------------------------------------------------------*
//  SqlResultSetPrior
//---------------------------------------------------------------*
//* Moves the cursor to the prior row in this ResultSet object.
//+ 
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//*
//* @return *on - if the cursor is on a valid row
//* @return *off - false if there are no rows in the result set
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetPrior export;
  dcl-pi *N ind;
    pInResultSet int(10) const;
  end-pi;

  dcl-s pPtResultSet pointer inz(*Null);
  dcl-ds pDsResultSet likeds(DsResultSet_t) based(pPtResultSet); 

  dcl-s pPtResultDa pointer;
  dcl-ds pDsResultDa likeds(SqlDa) based(pPtResultDa);

  pPtResultSet = OoRObjectGet(s#prog:pInResultSet);
  if pPtResultSet = *Null;
    // todo message
    // TODO Exception ?
    return *off;
  endif;

  pPtResultDa = pDsResultSet.ptResultDa;
  pDsResultSet.SqPrcEd.function = SQL_FUNCTION_FETCH;
  pDsResultSet.SqPrcEd.position = SQL_FETCH_PRIOR;
  
  Q_SqPrcEd(SqlCa:pDsResultDa:'SQLP0400':pDsResultSet.SqPrcEd:QUSecExcp);

  if SqlCode <> 0;
    // TODO Exception ?
    return *off;
  endif;
  
  return *on;

end-proc SqlResultSetPrior;
//---------------------------------------------------------------*
//  SqlResultSetRelative
//---------------------------------------------------------------*
//* Moves the cursor to the given row number in this ResultSet.
//+ 
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInRow - The number of rows forward or backward to move before retrieving data. 
//*                 A positive number means forward and a negative number, backward.  
//*
//* @return *on - if the cursor is moved to a position in this ResultSet object
//* @return *off - if the cursor is before the first row or after the last row
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetRelative export;
  dcl-pi *N ind;
    pInResultSet int(10) const;
    pInRows int(10) const;
  end-pi;

  dcl-s pPtResultSet pointer inz(*Null);
  dcl-ds pDsResultSet likeds(DsResultSet_t) based(pPtResultSet); 

  dcl-s pPtResultDa pointer;
  dcl-ds pDsResultDa likeds(SqlDa) based(pPtResultDa);

  pPtResultSet = OoRObjectGet(s#prog:pInResultSet);
  if pPtResultSet = *Null;
    // todo message
    // TODO Exception ?
    return *off;
  endif;

  pPtResultDa = pDsResultSet.ptResultDa;
  pDsResultSet.SqPrcEd.function = SQL_FUNCTION_FETCH;
  pDsResultSet.SqPrcEd.position = SQL_FETCH_RELATIVE;
  pDsResultSet.SqPrcEd.rrn = pInRows; 
  
  Q_SqPrcEd(SqlCa:pDsResultDa:'SQLP0400':pDsResultSet.SqPrcEd:QUSecExcp);

  if SqlCode <> 0;
    // TODO Exception ?
    return *off;
  endif;
  
  return *on;

end-proc SqlResultSetRelative;
//---------------------------------------------------------------*
//  SqlResultSetAbsolut
//---------------------------------------------------------------*
//* Moves the cursor to the given row number in this ResultSet object.
//+ 
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInRow - the number of the row to which the cursor should move. 
//*                 A value of zero indicates that the cursor will be 
//*                 positioned before the first row; a positive number 
//*                 indicates the row number counting from the beginning 
//*                 of the result set; a negative number indicates the row 
//*                 number counting from the end of the result set  
//*
//* @return *on - if the cursor is moved to a position in this ResultSet object
//* @return *off - if the cursor is before the first row or after the last row
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetAbsolut export;
  dcl-pi *N ind;
    pInResultSet int(10) const;
    pInRows int(10) const;
  end-pi;

  dcl-s pPtResultSet pointer inz(*Null);
  dcl-ds pDsResultSet likeds(DsResultSet_t) based(pPtResultSet); 

  dcl-s pPtResultDa pointer;
  dcl-ds pDsResultDa likeds(SqlDa) based(pPtResultDa);

  pPtResultSet = OoRObjectGet(s#prog:pInResultSet);
  if pPtResultSet = *Null;
    // todo message
    // TODO Exception ?
    return *off;
  endif;

  if PInRows >= 0;
    if not SqlResultSetBeforeFirst(pInResultSet);
      return *off;
    endif;
  else;  
    if not SqlResultSetAfterLast(pInResultSet);
      return *off;
    endif;
  endif;

  pPtResultDa = pDsResultSet.ptResultDa;
  pDsResultSet.SqPrcEd.function = SQL_FUNCTION_FETCH;
  pDsResultSet.SqPrcEd.position = SQL_FETCH_RELATIVE;
  pDsResultSet.SqPrcEd.rrn = pInRows; 
  
  Q_SqPrcEd(SqlCa:pDsResultDa:'SQLP0400':pDsResultSet.SqPrcEd:QUSecExcp);

  if SqlCode <> 0;
    // TODO Exception ?
    return *off;
  endif;
  
  return *on;

end-proc SqlResultSetAbsolut;
//---------------------------------------------------------------*
//  SqlResultSetRefreshRow
//---------------------------------------------------------------*
//* Refreshes the current row with its most recent value in the database.
//+ 
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//*
//* @return *on - if the cursor is on a valid row
//* @return *off - false if there are no rows in the result set
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetRefreshRow export;
  dcl-pi *N ind;
    pInResultSet int(10) const;
  end-pi;

  dcl-s pPtResultSet pointer inz(*Null);
  dcl-ds pDsResultSet likeds(DsResultSet_t) based(pPtResultSet); 

  dcl-s pPtResultDa pointer;
  dcl-ds pDsResultDa likeds(SqlDa) based(pPtResultDa);

  pPtResultSet = OoRObjectGet(s#prog:pInResultSet);
  if pPtResultSet = *Null;
    // todo message
    // TODO Exception ?
    return *off;
  endif;

  pPtResultDa = pDsResultSet.ptResultDa;
  pDsResultSet.SqPrcEd.function = SQL_FUNCTION_FETCH;
  pDsResultSet.SqPrcEd.position = SQL_FETCH_CURRENT;
  
  Q_SqPrcEd(SqlCa:pDsResultDa:'SQLP0400':pDsResultSet.SqPrcEd:QUSecExcp);

  if SqlCode <> 0;
    // TODO Exception ?
    return *off;
  endif;
  
  return *on;
         
end-proc SqlResultSetRefreshRow;
//---------------------------------------------------------------*
//  SqlResultSetFirst
//---------------------------------------------------------------*
//* Moves the cursor to the first row in this ResultSet object.
//+ 
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//*
//* @return *on - if the cursor is on a valid row
//* @return *off - if there are no rows in the result set
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetFirst export;
  dcl-pi *N ind;
    pInResultSet int(10) const;
  end-pi;

  dcl-s pPtResultSet pointer inz(*Null);
  dcl-ds pDsResultSet likeds(DsResultSet_t) based(pPtResultSet); 

  dcl-s pPtResultDa pointer;
  dcl-ds pDsResultDa likeds(SqlDa) based(pPtResultDa);

  pPtResultSet = OoRObjectGet(s#prog:pInResultSet);
  if pPtResultSet = *Null;
    // todo message
    // TODO Exception ?
    return *off;
  endif;

  pPtResultDa = pDsResultSet.ptResultDa;
  pDsResultSet.SqPrcEd.function = SQL_FUNCTION_FETCH;
  pDsResultSet.SqPrcEd.position = SQL_FETCH_FIRST;
  
  Q_SqPrcEd(SqlCa:pDsResultDa:'SQLP0400':pDsResultSet.SqPrcEd:QUSecExcp);

  if SqlCode <> 0;
    // TODO Exception ?
    return *off;
  endif;
  
  return *on;

end-proc SqlResultSetFirst;
//---------------------------------------------------------------*
//  SqlResultSetLast
//---------------------------------------------------------------*
//* Moves the cursor to the last row in this ResultSet object.
//+ 
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//*
//* @return *on - if the cursor is on a valid row
//* @return *off - false if there are no rows in the result set
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetLast export;
  dcl-pi *N ind;
    pInResultSet int(10) const;
  end-pi;

  dcl-s pPtResultSet pointer inz(*Null);
  dcl-ds pDsResultSet likeds(DsResultSet_t) based(pPtResultSet); 

  dcl-s pPtResultDa pointer;
  dcl-ds pDsResultDa likeds(SqlDa) based(pPtResultDa);

  pPtResultSet = OoRObjectGet(s#prog:pInResultSet);
  if pPtResultSet = *Null;
    // todo message
    // TODO Exception ?
    return *off;
  endif;

  pPtResultDa = pDsResultSet.ptResultDa;
  pDsResultSet.SqPrcEd.function = SQL_FUNCTION_FETCH;
  pDsResultSet.SqPrcEd.position = SQL_FETCH_LAST;
  
  Q_SqPrcEd(SqlCa:pDsResultDa:'SQLP0400':pDsResultSet.SqPrcEd:QUSecExcp);

  if SqlCode <> 0;
    // TODO Exception ?
    return *off;
  endif;
  
  return *on;

end-proc SqlResultSetLast;
//---------------------------------------------------------------*
//  SqlResultSetBeforeFirst
//---------------------------------------------------------------*
//* Moves the cursor to the front of this ResultSet object, just 
//* before the first row. This method has no effect if the result set contains no rows.
//+ 
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//*
//* @return *on - if the cursor is on a valid row
//* @return *off - false if there are no rows in the result set
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetBeforeFirst export;
  dcl-pi *N ind;
    pInResultSet int(10) const;
  end-pi;

  dcl-s pPtResultSet pointer inz(*Null);
  dcl-ds pDsResultSet likeds(DsResultSet_t) based(pPtResultSet); 

  dcl-s pPtResultDa pointer;
  dcl-ds pDsResultDa likeds(SqlDa) based(pPtResultDa);

  pPtResultSet = OoRObjectGet(s#prog:pInResultSet);
  if pPtResultSet = *Null;
    // TODO Exception ?
    // todo message
    return *off;
  endif;

  pPtResultDa = pDsResultSet.ptResultDa;
  pDsResultSet.SqPrcEd.function = SQL_FUNCTION_FETCH;
  pDsResultSet.SqPrcEd.position = SQL_FETCH_BEFORE;
  
  Q_SqPrcEd(SqlCa:pDsResultDa:'SQLP0400':pDsResultSet.SqPrcEd:QUSecExcp);

  if SqlCode <> 0;
    // TODO Exception ?
    return *off;
  endif;
  
  return *on;

end-proc SqlResultSetBeforeFirst;
//---------------------------------------------------------------*
//  SqlResultSetAfterLast
//---------------------------------------------------------------*
//* Moves the cursor to the end of this ResultSet object, just 
//* after the last row. This method has no effect if the result 
//* set contains no rows.
//+ 
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//*
//* @return *on - if the cursor is on a valid row
//* @return *off - false if there are no rows in the result set
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetAfterLast export;
  dcl-pi *N ind;
    pInResultSet int(10) const;
  end-pi;

  dcl-s pPtResultSet pointer inz(*Null);
  dcl-ds pDsResultSet likeds(DsResultSet_t) based(pPtResultSet); 

  dcl-s pPtResultDa pointer;
  dcl-ds pDsResultDa likeds(SqlDa) based(pPtResultDa);

  pPtResultSet = OoRObjectGet(s#prog:pInResultSet);
  if pPtResultSet = *Null;
    // todo message
    // TODO Exception ?
    return *off;
  endif;

  pPtResultDa = pDsResultSet.ptResultDa;
  pDsResultSet.SqPrcEd.function = SQL_FUNCTION_FETCH;
  pDsResultSet.SqPrcEd.position = SQL_FETCH_AFTER;
  
  Q_SqPrcEd(SqlCa:pDsResultDa:'SQLP0400':pDsResultSet.SqPrcEd:QUSecExcp);

  if SqlCode <> 0;
    // TODO Exception ?
    return *off;
  endif;
  
  return *on;

end-proc SqlResultSetAfterLast;
//---------------------------------------------------------------*
//  SqlResultSetClose
//---------------------------------------------------------------*
//* Close result set and free all resources.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//*
//* @return ccc
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetClose export;
  dcl-pi *N int(10);
    pInResultSet int(10) const;
  end-pi;

  dcl-s pPtResultSet pointer inz(*Null);
  dcl-ds pDsResultSet likeds(DsResultSet_t) based(pPtResultSet); 

  dcl-s pPtResultDa pointer;
  dcl-ds pDsResultDa likeds(SqlDa) based(pPtResultDa);

  pPtResultSet = OoRObjectGet(s#prog:pInResultSet);
  if pPtResultSet = *Null;
    // todo message
    return -1;
  endif;
 
  pPtResultDa = pDsResultSet.ptResultDa;
  pDsResultSet.SqPrcEd.function = SQL_FUNCTION_CLOSE;
  
  Q_SqPrcEd(SqlCa:SqlDa:'SQLP0400':pDsResultSet.SqPrcEd:QUSecExcp);

  if pDsResultSet.RelatedStatement > 0;
    SqlPreparedStatementFree(pDsResultSet.RelatedStatement);
  endif;

  dealloc(ne) pDsResultSet.ptResultDa;
  dealloc(ne) pDsResultSet.ptSqlVars;
  dealloc(ne) pDsResultSet.ptData;
  dealloc(ne) pDsResultSet.ptInd;

  OoRObjectFree(s#prog:pInResultSet);

  return 0;

end-proc SqlResultSetClose;
//---------------------------------------------------------------*
//  SqlResultSetGetString
//---------------------------------------------------------------*
//* Retrieve the value of the designated column in the current row.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//* @param pBoNullId - returns *on if column is NULL (optional)
//*
//* @return String
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetString export;
  dcl-pi *N varchar(32767);
    pInResultSet int(10) const;
    pInColIndex int(10) const;
    pBoNullId ind options(*nopass);
  end-pi;
       
  dcl-s inLen int(5) based(gDsSqlVar.SqlData);     
  dcl-s inLongLen int(10) based(gDsSqlVar.SqlData);     
       
  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = *on;    
  endif;     

  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return '';
  endif;  

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = gDsSqlVar.SqlIsNull;    
  endif;     

  if gDsSqlVar.SqlIsNull Or gDsSqlVar.SqlHasError;
    return '';
  endif;

  if gDsSqlVar.SqlType = SQL_TYPE_CHAR;
    return %str(gDsSqlVar.SqlData:gDsSqlVar.SqlLen);     
  endif;     

  if gDsSqlVar.SqlType = SQL_TYPE_VARCHAR And inLen > 0;
    return %str(gDsSqlVar.SqlData + %size(inLen):inLen);     
  endif;     

  if gDsSqlVar.SqlType = SQL_TYPE_LONGVARCHAR And inLongLen > 0;
    return %str(gDsSqlVar.SqlData  + %size(inLongLen):inLongLen);     
  endif;     

  if gDsSqlVar.SqlType = SQL_TYPE_GRAPHIC Or
       gDsSqlVar.SqlType = SQL_TYPE_VARGRAPHIC Or
       gDsSqlVar.SqlType = SQL_TYPE_LONGVARGRAPHIC Or
       gDsSqlVar.SqlType = SQL_TYPE_DBCLOB;
    return %char(SqlResultSetGetStringUcs(pInResultSet:pInColIndex));     
  endif;     

  if gDsSqlVar.SqlType = SQL_TYPE_CLOB Or
       gDsSqlVar.SqlType = SQL_TYPE_BLOB Or
       gDsSqlVar.SqlType = SQL_TYPE_XML;
    if gDsSqlVar.SqlBytes <= 32767;   
      return %str(gDsSqlVar.SqlData:gDsSqlVar.SqlBytes);
    else;  
      return %str(gDsSqlVar.SqlData:32767);
    endif;       
  endif;     

  return '';     
       
end-proc SqlResultSetGetString;
//---------------------------------------------------------------*
//  SqlResultSetGetStringUcs
//---------------------------------------------------------------*
//* Retrieve the value of the designated column in the current row.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//* @param pBoNullId - returns *on if column is NULL (optional)
//*
//* @return Ucs String
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetStringUcs export;
  dcl-pi *N varucs2(16383);
    pInResultSet int(10) const;
    pInColIndex int(10) const;
    pBoNullId ind options(*nopass);
  end-pi;
       
  dcl-s pAnUcs2 ucs2(16383) based(gDsSqlVar.SqlData);     
  dcl-s pAnVarUcs2 varucs2(16383:2) based(gDsSqlVar.SqlData);     
  dcl-s pAnLongUcs2 varucs2(16383:4) based(gDsSqlVar.SqlData);     

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = *on;    
  endif;     

  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return %ucs2('');
  endif;  

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = gDsSqlVar.SqlIsNull;    
  endif;     

  if gDsSqlVar.SqlIsNull Or gDsSqlVar.SqlHasError;
    return %ucs2('');
  endif;

  // todo char with ccsid 

  if gDsSqlVar.SqlType = SQL_TYPE_GRAPHIC; 
    return %subst(pAnUcs2:1:gDsSqlVar.SqlLen);     
  endif;     

  if gDsSqlVar.SqlType = SQL_TYPE_VARGRAPHIC; 
    return %subst(pAnVarUcs2:1:%len(pAnVarUcs2));     
  endif;     

  if gDsSqlVar.SqlType = SQL_TYPE_LONGVARGRAPHIC; 
    return %subst(pAnLongUcs2:1:%len(pAnLongUcs2));     
  endif;     

  if gDsSqlVar.SqlType = SQL_TYPE_DBCLOB; 
    if gDsSqlVar.SqlBytes <= 32766;
      return %subst(pAnUcs2:1:%div(gDsSqlVar.SqlBytes:2));     
    else;
      return %subst(pAnUcs2:1:16383);     
    endif;     
  endif;     

  if gDsSqlVar.SqlType = SQL_TYPE_CHAR Or
       gDsSqlVar.SqlType = SQL_TYPE_VARCHAR Or
       gDsSqlVar.SqlType = SQL_TYPE_LONGVARCHAR Or
       gDsSqlVar.SqlType = SQL_TYPE_CLOB Or
       gDsSqlVar.SqlType = SQL_TYPE_BLOB Or
       gDsSqlVar.SqlType = SQL_TYPE_XML;
    return %ucs2(SqlResultSetGetString(pInResultSet:pInColIndex));     
  endif;     

  return %ucs2('');
       
end-proc SqlResultSetGetStringUcs;
//---------------------------------------------------------------*
//  SqlResultSetGetDecimal
//---------------------------------------------------------------*
//* Retrieve the value of the designated column in the current row.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//* @param pBoNullId - returns *on if column is NULL (optional)
//*
//* @return Decimal
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetDecimal export;
  dcl-pi *N packed(31:11);
    pInResultSet int(10) const;
    pInColIndex int(10) const;
    pBoNullId ind options(*nopass);
  end-pi;
       
  dcl-s pNuPacked packed(31:0) inz(0);     
  dcl-s pNuZoned zoned(31:0) inz(0);     
       
  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = *on;    
  endif;     

  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return 0;
  endif;  

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = gDsSqlVar.SqlIsNull;    
  endif;     

  if gDsSqlVar.SqlIsNull Or gDsSqlVar.SqlHasError;
    return 0;
  endif;

  if gDsSqlVar.SqlType = SQL_TYPE_PACKED;
    memcpy(%addr(pNuPacked) + %size(pNuPacked) - gDsSqlVar.SqlBytes
          :gDsSqlVar.SqlData  
          :gDsSqlVar.SqlBytes);
    return pNuPacked / 10 ** gDsSqlVar.SqlScale;
  endif;
    
  if gDsSqlVar.SqlType = SQL_TYPE_ZONED;
    memcpy(%addr(pNuZoned) + %size(pNuZoned) - gDsSqlVar.SqlBytes
          :gDsSqlVar.SqlData  
          :gDsSqlVar.SqlBytes);
    return pNuZoned / 10 ** gDsSqlVar.SqlScale;
  endif;       

  if gDsSqlVar.SqlType = SQL_TYPE_FLOAT;
    return(h) SqlResultSetGetDouble(pInResultSet:pInColIndex);
  endif;       

  if gDsSqlVar.SqlType = SQL_TYPE_SMALLINT Or
       gDsSqlVar.SqlType = SQL_TYPE_INT Or
       gDsSqlVar.SqlType = SQL_TYPE_BIGINT;
    return SqlResultSetGetLong(pInResultSet:pInColIndex);
  endif;       

  return 0;     
       
end-proc SqlResultSetGetDecimal;
//---------------------------------------------------------------*
//  SqlResultSetGetDouble
//---------------------------------------------------------------*
//* Retrieve the value of the designated column in the current row.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//* @param pBoNullId - returns *on if column is NULL (optional)
//*
//* @return Double
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetDouble export;
  dcl-pi *N float(8);
    pInResultSet int(10) const;
    pInColIndex int(10) const;
    pBoNullId ind options(*nopass);
  end-pi;

  dcl-s pDbDouble float(8) based(gDsSqlVar.SqlData);
  dcl-s pFlFloat float(4) based(gDsSqlVar.SqlData);

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = *on;    
  endif;     

  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return 0;
  endif;  

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = gDsSqlVar.SqlIsNull;    
  endif;     

  if gDsSqlVar.SqlIsNull Or gDsSqlVar.SqlHasError;
    return 0;
  endif;

  if gDsSqlVar.SqlType = SQL_TYPE_FLOAT And gDsSqlVar.SqlBytes = %size(pFlFloat); 
    return pFlFloat;
  endif;
    
  if gDsSqlVar.SqlType = SQL_TYPE_FLOAT And gDsSqlVar.SqlBytes = %size(pDbDouble);
    return pDbDouble;
  endif;
  
  if gDsSqlVar.SqlType = SQL_TYPE_PACKED Or
       gDsSqlVar.SqlType = SQL_TYPE_ZONED;
    return SqlResultSetGetDecimal(pInResultSet:pInColIndex);
  endif;       

  if gDsSqlVar.SqlType = SQL_TYPE_SMALLINT Or
       gDsSqlVar.SqlType = SQL_TYPE_INT Or
       gDsSqlVar.SqlType = SQL_TYPE_BIGINT;
    return SqlResultSetGetLong(pInResultSet:pInColIndex);
  endif;       

  return 0;     
       
end-proc SqlResultSetGetDouble;
//---------------------------------------------------------------*
//  SqlResultSetGetDate
//---------------------------------------------------------------*
//* Retrieve the value of the designated column in the current row.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//* @param pBoNullId - returns *on if column is NULL (optional)
//*
//* @return Date
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetDate export;
  dcl-pi *N date;
    pInResultSet int(10) const;
    pInColIndex int(10) const;
    pBoNullId ind options(*nopass);
  end-pi;
      
  dcl-s pDaDate date based(gDsSqlVar.SqlData);    
       
  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = *on;    
  endif;     

  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return *loval;
  endif;  

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = gDsSqlVar.SqlIsNull;    
  endif;     

  if gDsSqlVar.SqlIsNull Or gDsSqlVar.SqlHasError;
    return *loval;
  endif;

  if gDsSqlVar.SqlType = SQL_TYPE_DATE;
    return pDaDate; 
  endif;

  if gDsSqlVar.SqlType = SQL_TYPE_TIMESTAMP;
    return %date(SqlResultSetGetTimeStamp(pInResultSet:pInColIndex));
  endif;
  
  return *loval;     
       
end-proc SqlResultSetGetDate;
//---------------------------------------------------------------*
//  SqlResultSetGetTime
//---------------------------------------------------------------*
//* Retrieve the value of the designated column in the current row.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//* @param pBoNullId - returns *on if column is NULL (optional)
//*
//* @return Time
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetTime export;
  dcl-pi *N time;
    pInResultSet int(10) const;
    pInColIndex int(10) const;
    pBoNullId ind options(*nopass);
  end-pi;
       
  dcl-s pTiTime time based(gDsSqlVar.SqlData);    
  dcl-s pAnTime char(8) based(gDsSqlVar.SqlData);    

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = *on;    
  endif;     

  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return *loval;
  endif;  

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = gDsSqlVar.SqlIsNull;    
  endif;     

  if gDsSqlVar.SqlIsNull Or gDsSqlVar.SqlHasError;
    return *loval;
  endif;

  if gDsSqlVar.SqlType = SQL_TYPE_TIME;
    %subst(pAnTime:3:1) = '.'; 
    %subst(pAnTime:6:1) = '.'; 
    return pTiTime; 
  endif;
  
  if gDsSqlVar.SqlType = SQL_TYPE_TIMESTAMP;
    return %time(SqlResultSetGetTimeStamp(pInResultSet:pInColIndex));
  endif;
  
  return *loval;     
       
end-proc SqlResultSetGetTime;
//---------------------------------------------------------------*
//  SqlResultSetGetTimeStamp
//---------------------------------------------------------------*
//* Retrieve the value of the designated column in the current row.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//* @param pBoNullId - returns *on if column is NULL (optional)
//*
//* @return Timestamp
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetTimeStamp export;
  dcl-pi *N timestamp;
    pInResultSet int(10) const;
    pInColIndex int(10) const;
    pBoNullId ind options(*nopass);
  end-pi;
       
  dcl-s pTsTime timestamp based(gDsSqlVar.SqlData);    

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = *on;    
  endif;     

  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return *loval;
  endif;  

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = gDsSqlVar.SqlIsNull;    
  endif;     

  if gDsSqlVar.SqlIsNull Or gDsSqlVar.SqlHasError;
    return *loval;
  endif;

  if gDsSqlVar.SqlType = SQL_TYPE_TIMESTAMP;
    return pTsTime; 
  endif;
  
  if gDsSqlVar.SqlType = SQL_TYPE_DATE;
    return %timestamp(SqlResultSetGetDate(pInResultSet:pInColIndex)
                      + t'00.00.00'); 
  endif;

  return *loval;     
       
end-proc SqlResultSetGetTimeStamp;
//---------------------------------------------------------------*
//  SqlResultSetGetLong
//---------------------------------------------------------------*
//* Retrieve the value of the designated column in the current row.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//* @param pBoNullId - returns *on if column is NULL (optional)
//*
//* @return Timestamp
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetLong export;
  dcl-pi *N int(20);
    pInResultSet int(10) const;
    pInColIndex int(10) const;
    pBoNullId ind options(*nopass);
  end-pi;
       
  dcl-s pInSmall int(5) based(gDsSqlVar.SqlData);
  dcl-s pInInt int(10) based(gDsSqlVar.SqlData);
  dcl-s pInBig int(20) based(gDsSqlVar.SqlData);

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = *on;    
  endif;     

  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return 0;
  endif;  

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = gDsSqlVar.SqlIsNull;    
  endif;     

  if gDsSqlVar.SqlIsNull Or gDsSqlVar.SqlHasError;
    return 0;
  endif;

  if gDsSqlVar.SqlType = SQL_TYPE_BIGINT;
    return pInBig;
  endif;
    
  if gDsSqlVar.SqlType = SQL_TYPE_INT;
    return pInInt;
  endif;
  
  if gDsSqlVar.SqlType = SQL_TYPE_SMALLINT;  
    return pInSmall;
  endif;

  if gDsSqlVar.SqlType = SQL_TYPE_PACKED Or
       gDsSqlVar.SqlType = SQL_TYPE_ZONED;
    return SqlResultSetGetDecimal(pInResultSet:pInColIndex);
  endif;       

  if gDsSqlVar.SqlType = SQL_TYPE_FLOAT;
    return SqlResultSetGetDecimal(pInResultSet:pInColIndex);
  endif;       

  return 0;     
       
end-proc SqlResultSetGetLong;
//---------------------------------------------------------------*
//  SqlResultSetGetHex
//---------------------------------------------------------------*
//* Retrieve the value of the designated column in the current row.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//* @param pBoNullId - returns *on if column is NULL (optional)
//*
//* @return Timestamp
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetHex export;
  dcl-pi *N varchar(32767);
    pInResultSet int(10) const;
    pInColIndex int(10) const;
    pBoNullId ind options(*nopass);
  end-pi;
       
  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = *on;    
  endif;     

  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return '';
  endif;  

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = gDsSqlVar.SqlIsNull;    
  endif;     

  if gDsSqlVar.SqlIsNull Or gDsSqlVar.SqlHasError;
    return '';
  endif;

  if gDsSqlVar.SqlType = SQL_TYPE_DBCLOB Or
       gDsSqlVar.SqlType = SQL_TYPE_CLOB Or
       gDsSqlVar.SqlType = SQL_TYPE_BLOB Or
       gDsSqlVar.SqlType = SQL_TYPE_XML;
    if gDsSqlVar.SqlBytes <= 32767;  
      return %str(gDsSqlVar.SqlData:gDsSqlVar.SqlBytes); 
    else;
      return %str(gDsSqlVar.SqlData:32767); 
    endif;     
  endif;     

  return %str(gDsSqlVar.SqlData:gDsSqlVar.SqlBytes); 

end-proc SqlResultSetGetHex;
//---------------------------------------------------------------*
//  SqlResultSetGetBlob
//---------------------------------------------------------------*
//* Retrieves the value of the designated column in the current row 
//* of this ResultSet object as a Blob object #link ARSSQLR.ARSSQL03
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//* @param pBoNullId - returns *on if column is NULL (optional)
//*
//* @return Blob
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetBlob export;
  dcl-pi *N int(10);
    pInResultSet int(10) const;
    pInColIndex int(10) const;
    pBoNullId ind options(*nopass);
  end-pi;
       
  dcl-s inSqlLocator int(10) based(gDsSqlVar.SqlData);     

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = *on;    
  endif;     

  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return -1;
  endif;  

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = gDsSqlVar.SqlIsNull;    
  endif;     

  if gDsSqlVar.SqlIsNull Or gDsSqlVar.SqlHasError;
    return -1;
  endif;

  if gDsSqlVar.SqlType <> SQL_TYPE_BLOB_LOCATOR;
    return -1; 
  endif;     

  SqlBlobFree(gDsSqlVar.SqlLob);
  gDsSqlVar.SqlLob = SqlBlobNew(gDsResultSet.SqPrcEd:inSqlLocator); 
  
  return gDsSqlVar.SqlLob;
       
end-proc SqlResultSetGetBlob;
//---------------------------------------------------------------*
//  SqlResultSetGetClob
//---------------------------------------------------------------*
//* Retrieves the value of the designated column in the current row 
//* of this ResultSet object as a Clob object #link ARSSQLR.ARSSQL04
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//*
//* @return Clob
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetClob export;
  dcl-pi *N int(10);
    pInResultSet int(10) const;
    pInColIndex int(10) const;
    pBoNullId ind options(*nopass);
  end-pi;
       
  dcl-s inSqlLocator int(10) based(gDsSqlVar.SqlData);     

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = *on;    
  endif;     

  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return -1;
  endif;  

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = gDsSqlVar.SqlIsNull;    
  endif;     

  if gDsSqlVar.SqlIsNull Or gDsSqlVar.SqlHasError;
    return -1;
  endif;

  if gDsSqlVar.SqlType <> SQL_TYPE_CLOB_LOCATOR;
    return -1; 
  endif;     

  SqlClobFree(gDsSqlVar.SqlLob);
  gDsSqlVar.SqlLob = SqlClobNew(gDsResultSet.SqPrcEd:inSqlLocator); 
  
  return gDsSqlVar.SqlLob;
       
end-proc SqlResultSetGetClob;
//---------------------------------------------------------------*
//  SqlResultSetGetDbClob
//---------------------------------------------------------------*
//* Retrieves the value of the designated column in the current row 
//* of this ResultSet object as a DbClob object #link ARSSQLR.ARSSQL05
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//*
//* @return DbClob
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetDbClob export;
  dcl-pi *N int(10);
    pInResultSet int(10) const;
    pInColIndex int(10) const;
    pBoNullId ind options(*nopass);
  end-pi;
       
  dcl-s inSqlLocator int(10) based(gDsSqlVar.SqlData);     

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = *on;    
  endif;     

  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return -1;
  endif;  

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = gDsSqlVar.SqlIsNull;    
  endif;     

  if gDsSqlVar.SqlIsNull Or gDsSqlVar.SqlHasError;
    return -1;
  endif;

  if gDsSqlVar.SqlType <> SQL_TYPE_DBCLOB_LOCATOR;
    return -1; 
  endif;     

  SqlDbClobFree(gDsSqlVar.SqlLob);
  gDsSqlVar.SqlLob = SqlDbClobNew(gDsResultSet.SqPrcEd:inSqlLocator); 
  
  return gDsSqlVar.SqlLob;
       
end-proc SqlResultSetGetDbClob;
//---------------------------------------------------------------*
//  SqlResultSetGetSqlXml
//---------------------------------------------------------------*
//* Retrieves the value of the designated column in the current row 
//* of this ResultSet object as a SqlXml object #link ARSSQLR.ARSSQL06
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//*
//* @return SqlXml
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetSqlXml export;
  dcl-pi *N int(10);
    pInResultSet int(10) const;
    pInColIndex int(10) const;
    pBoNullId ind options(*nopass);
  end-pi;
       
  dcl-s inSqlLocator int(10) based(gDsSqlVar.SqlData);     

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = *on;    
  endif;     

  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return -1;
  endif;  

  if %parms() >= %parmnum(pBoNullId) Or 
       %parms() = -1 And %addr(pBoNullId) <> *Null;
    pBoNullId = gDsSqlVar.SqlIsNull;    
  endif;     

  if gDsSqlVar.SqlIsNull Or gDsSqlVar.SqlHasError;
    return -1;
  endif;

  if gDsSqlVar.SqlType <> SQL_TYPE_XML_LOCATOR;
    return -1; 
  endif;     
  
  SqlSqlXmlFree(gDsSqlVar.SqlLob);
  gDsSqlVar.SqlLob = SqlSqlXmlNew(gDsResultSet.SqPrcEd:inSqlLocator); 
  
  return gDsSqlVar.SqlLob;
       
end-proc SqlResultSetGetSqlXml;
//---------------------------------------------------------------*
//  SqlResultSetIsNull
//---------------------------------------------------------------*
//* Whether the column is NULL.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//*
//* @return *on - is NULL else *off
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetIsNull export;
  dcl-pi *N ind;
    pInResultSet int(10) const;
    pInColIndex int(10) const;
  end-pi;
       
  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return *on;
  endif;  

  return gDsSqlVar.SqlIsNull;    

end-proc SqlResultSetIsNull;
//---------------------------------------------------------------*
//  SqlResultSetHasError
//---------------------------------------------------------------*
//* Whether the column has errors.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//*
//* @return *on - has errors else *off
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetHasError export;
  dcl-pi *N ind;
    pInResultSet int(10) const;
    pInColIndex int(10) const;
  end-pi;
       
  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return *on;
  endif;  

  return gDsSqlVar.SqlHasError;    

end-proc SqlResultSetHasError;
//---------------------------------------------------------------*
//  SqlResultSetFindColumn
//---------------------------------------------------------------*
//* Maps the given column label to its column index. 
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pAnColName - Column label.
//*
//* @return column index of given column name.
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetFindColumn export;
  dcl-pi *N int(10);
    pInResultSet int(10) const;
    pAnColName varchar(256) const;
  end-pi;
       
  dcl-s pInColumns int(10);     
  dcl-s i int(10);     
       
  pInColumns = SqlResultSetGetColumnCount(pInResultSet);      
  for i=1 by 1 to pInColumns;
    if SqlGetSqlVar(pInResultSet:i) <> 0; // ??
      return -1; 
    endif;  
    if gDsSqlVar.SqlLongName = PAnColName Or
         gDsSqlVar.SqlSysName = PAnColName;
      return i;
    endif;       
  endfor; 

  return -1;
       
end-proc SqlResultSetFindColumn;
//---------------------------------------------------------------*
//  SqlResultSetGetColumnCount
//---------------------------------------------------------------*
//* Retrieve the number of columns.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//*
//* @return Number of columns
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetColumnCount export;
  dcl-pi *N int(10);
    pInResultSet int(10) const;
  end-pi;
        
  dcl-s pPtResultSet pointer inz(*Null);
  dcl-ds pDsResultSet likeds(DsResultSet_t) based(pPtResultSet); 

  dcl-s pPtResultDa pointer;
  dcl-ds pDsResultDa likeds(SqlDa) based(pPtResultDa);

  pPtResultSet = OoRObjectGet(s#prog:pInResultSet);
  if pPtResultSet = *Null;
    // todo message
    return 0;
  endif;

  pPtResultDa = pDsResultSet.ptResultDa; 
  return pDsResultDa.SqlD;
              
end-proc SqlResultSetGetColumnCount;
//---------------------------------------------------------------*
//  SqlResultSetGetColumnName
//---------------------------------------------------------------*
//* Retrieve the name of a column.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//*
//* @return Column name.
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetColumnName export;
  dcl-pi *N varchar(256);
    pInResultSet int(10) const;
    pInColIndex int(10) const;
  end-pi;
       
  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return '';
  endif;  
  
  if gDsSqlVar.SqlLongName <> *Blanks;
    return gDsSqlVar.SqlLongName;     
  endif; 
  
  return gDsSqlVar.SqlSysName;     
              
end-proc SqlResultSetGetColumnName;
//---------------------------------------------------------------*
//  SqlResultSetGetSysColumnName
//---------------------------------------------------------------*
//* Retrieve system name of column.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//*
//* @return Column name
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetSysColumnName export;
  dcl-pi *N varchar(10);
    pInResultSet int(10) const;
    pInColIndex int(10) const;
  end-pi;
       
  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return '';
  endif;  
  
  return gDsSqlVar.SqlSysName;     
       
end-proc SqlResultSetGetSysColumnName;
//---------------------------------------------------------------*
//  SqlResultSetGetLongColumnName
//---------------------------------------------------------------*
//* Retrieve long name of column.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//*
//* @return Column name
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetLongColumnName export;
  dcl-pi *N varchar(256);
    pInResultSet int(10) const;
    pInColIndex int(10) const;
  end-pi;
       
  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return '';
  endif;  
  
  return gDsSqlVar.SqlLongName;     
       
end-proc SqlResultSetGetLongColumnName;
//---------------------------------------------------------------*
//  SqlResultSetGetColumnPrefix
//---------------------------------------------------------------*
//* ...                           
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//*
//* @return ...             
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetColumnPrefix export;
  dcl-pi *N char(1);
    pInResultSet int(10) const;
    pInColIndex int(10) const;
  end-pi;
       
  // TODO     
  return '';     
       
end-proc SqlResultSetGetColumnPrefix;
//---------------------------------------------------------------*
//  SqlResultSetGetColumnType
//---------------------------------------------------------------*
//* Retrieve SQL type of column.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//*
//* @return Sql type SQL_TYPE_* (@const SQL_TYPE_BINARY).
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetColumnType export;
  dcl-pi *N int(10);
    pInResultSet int(10) const;
    pInColIndex int(10) const;
  end-pi;
       
  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return 0;
  endif;  
       
  return gDsSqlVar.SqlType;     
       
end-proc SqlResultSetGetColumnType;
//---------------------------------------------------------------*
//  SqlResultSetGetPrecision
//---------------------------------------------------------------*
//* Retrieve precision of column.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//*
//* @return Precision
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetPrecision export;
  dcl-pi *N int(10);
    pInResultSet int(10) const;
    pInColIndex int(10) const;
  end-pi;
       
  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return 0;
  endif;  

  return gDsSqlVar.SqlPrecision;          
       
end-proc SqlResultSetGetPrecision;
//---------------------------------------------------------------*
//  SqlResultSetGetScale
//---------------------------------------------------------------*
//* Retrieve scale of column.
//*
//* @param pInResultSet - Result set @link ARSSQLR.ARSSQL02.SqlPreparedStatementExecuteQuery
//* @param pInColIndex - Index of column starting with 1
//*
//* @return Scale
//*
//* @diag messageCode to be defined
//*
//* @Author S.Allbach
//---------------------------------------------------------------*
dcl-proc SqlResultSetGetScale export;
  dcl-pi *N int(10);
    pInResultSet int(10) const;
    pInColIndex int(10) const;
  end-pi;
       
  if SqlGetSqlVar(pInResultSet:pInColIndex) <> 0;
    return 0;
  endif;  

  return gDsSqlVar.SqlScale;          
       
end-proc SqlResultSetGetScale;
//---------------------------------------------------------------*
//  SqlFillSqlVar
//---------------------------------------------------------------*
dcl-proc SqlFillSqlVar;
  dcl-pi *N int(10);
    pPtResultDa pointer const;
    pInColIndex int(10) const;
    pinSqlVarOccur int(10) const;
    pinFields int(10) const;
    pboLobAsString ind const;
  end-pi;
       
  dcl-ds pDsResultDa likeds(SqlDa) based(pPtResultDa);

  dcl-s pPtSqlVar pointer;
  dcl-ds pDsSqlVar likeds(SqlVar) based(pPtSqlVar);

  dcl-s pPtSqlVar2 pointer;
  dcl-ds pDsSqlVar2 likeds(SqlVar2) based(pPtSqlVar2);

  dcl-ds *n;
    inLen int(5);
    inPrecision int(3) overlay(inLen:*next); 
    inScale int(3) overlay(inLen:*next); 
  end-ds;

  clear gDsSqlVar; 
  pPtSqlVar = %Addr(pDsResultDa.Sql_Var(1)) + %size(SQLVAR) * (pInColIndex-1); 

  gDsSqlVar.SqlType = pDsSqlVar.SqlType - %rem(pDsSqlVar.SqlType:2);
  if %rem(pDsSqlVar.SqlType:2) = 0;
    pDsSqlVar.SqlType += 1;
  endif; 
  gDsSqlVar.SqlTypeOrig = pDsSqlVar.SqlType;
  gDsSqlVar.SqlLen = pDsSqlVar.SqlLen;
  gDsSqlVar.SqlFile = 0;
  memcpy(%Addr(gDsSqlVar.SqlFile) + 2
        :%Addr(pDsSqlVar.SqlRes) + 8:2);
  memcpy(%Addr(gDsSqlVar.SqlCcsid)
        :%Addr(pDsSqlVar.SqlInfo1)
        :%size(gDsSqlVar.SqlCcsid));
        
  if pDsSqlVar.SqlNameLen <= 8; 
    gDsSqlVar.SqlSysName = %subst(pDsSqlVar.SqlName:1:pDsSqlVar.SqlNameLen);
  else;  
    gDsSqlVar.SqlLongName = %subst(pDsSqlVar.SqlName:1:pDsSqlVar.SqlNameLen);
  endif;
        
  // move CCSID to name field
  pDsSqlVar.SqlNameLen = 8;        
  pDsSqlVar.SqlName = pDsSqlVar.SqlInfo1;

  // calculate byte length
  gDsSqlVar.SqlBytes = gDsSqlVar.SqlLen;
  
  select; 
    when gDsSqlVar.SqlType = SQL_TYPE_PACKED;
      inLen = pDsSqlVar.SqlLen; 
      gDsSqlVar.SqlPrecision = inPrecision; 
      gDsSqlVar.SqlScale = inScale; 
      gDsSqlVar.SqlBytes = %div(gDsSqlVar.SqlPrecision+1:2)
                         + %rem(gDsSqlVar.SqlPrecision+1:2);
           
    when gDsSqlVar.SqlType = SQL_TYPE_ZONED;
      inLen = pDsSqlVar.SqlLen; 
      gDsSqlVar.SqlPrecision = inPrecision; 
      gDsSqlVar.SqlScale = inScale; 
      gDsSqlVar.SqlBytes = gDsSqlVar.SqlPrecision;
           
    when gDsSqlVar.SqlType = SQL_TYPE_VARCHAR Or
           gDsSqlVar.SqlType = SQL_TYPE_LONGVARCHAR;
      gDsSqlVar.SqlBytes = gDsSqlVar.SqlLen + 2;
           
    when gDsSqlVar.SqlType = SQL_TYPE_GRAPHIC;
      gDsSqlVar.SqlBytes = gDsSqlVar.SqlLen * 2;
           
    when gDsSqlVar.SqlType = SQL_TYPE_VARGRAPHIC Or
          gDsSqlVar.SqlType = SQL_TYPE_LONGVARGRAPHIC;
      gDsSqlVar.SqlBytes = gDsSqlVar.SqlLen * 2 + 2;

  endsl;

  if pinSqlVarOccur = 1;
    return 0;
  endif;
    
  // SQLVAR 2  
  pPtSqlVar2 = %Addr(pDsResultDa.Sql_Var(1)) + %size(SQLVAR2) * (pinFields + pInColIndex-1);

  if pDsSqlVar2.SqlTNameLn > 0; 
    gDsSqlVar.SqlLongName = %subst(pDsSqlVar2.SqlTName:1:pDsSqlVar2.SqlTNameLn);
  endif;
  
  select;
    // DBC/C/BLOB as string
    when pboLobAsString And 
           (gDsSqlVar.SqlType = SQL_TYPE_BLOB Or
            gDsSqlVar.SqlType = SQL_TYPE_CLOB Or
            gDsSqlVar.SqlType = SQL_TYPE_DBCLOB);
      gDsSqlVar.SqlLen = pDsSqlVar2.SqlLongL;
      gDsSqlVar.SqlBytes = gDsSqlVar.SqlLen;
      pDsSqlVar2.SqlDataL = %addr(gDsSqlVar.SqlBytes);

    // BLOB as locator object
    when gDsSqlVar.SqlType = SQL_TYPE_BLOB;
      gDsSqlVar.SqlType = SQL_TYPE_BLOB_LOCATOR;
      gDsSqlVar.SqlTypeOrig = SQL_TYPE_BLOB_LOCATOR + %rem(gDsSqlVar.SqlTypeOrig:2);
      gDsSqlVar.SqlLen = pDsSqlVar2.SqlLongL; 
      gDsSqlVar.SqlBytes = %size(BlobLocator); 
      pDsSqlVar.SqlType = gDsSqlVar.SqlTypeOrig;
      ///////pDsSqlVar.SqlLen = gDsSqlVar.SqlBytes;
      ///////pDsSqlVar2.SqlLongL = 0;
           
    // CLOB as locator object
    when gDsSqlVar.SqlType = SQL_TYPE_CLOB;           
      gDsSqlVar.SqlType = SQL_TYPE_CLOB_LOCATOR;
      gDsSqlVar.SqlTypeOrig = SQL_TYPE_CLOB_LOCATOR + %rem(gDsSqlVar.SqlTypeOrig:2);
      gDsSqlVar.SqlLen = pDsSqlVar2.SqlLongL; 
      gDsSqlVar.SqlBytes = %size(BlobLocator); 
      pDsSqlVar.SqlType = gDsSqlVar.SqlTypeOrig;
      //////pDsSqlVar.SqlLen = gDsSqlVar.SqlBytes;
      //////pDsSqlVar2.SqlLongL = 0;
           
    // DBCLOB as locator object
    when gDsSqlVar.SqlType = SQL_TYPE_DBCLOB;
      gDsSqlVar.SqlType = SQL_TYPE_DBCLOB_LOCATOR;
      gDsSqlVar.SqlTypeOrig = SQL_TYPE_DBCLOB_LOCATOR + %rem(gDsSqlVar.SqlTypeOrig:2);
      gDsSqlVar.SqlLen = pDsSqlVar2.SqlLongL; 
      gDsSqlVar.SqlBytes = %size(BlobLocator); 
      pDsSqlVar.SqlType = gDsSqlVar.SqlTypeOrig;
      ///////pDsSqlVar.SqlLen = gDsSqlVar.SqlBytes;
      ///////pDsSqlVar2.SqlLongL = 0;
      
    // XML as locator object
    when gDsSqlVar.SqlType = SQL_TYPE_XML;
      gDsSqlVar.SqlType = SQL_TYPE_XML_LOCATOR;
      gDsSqlVar.SqlTypeOrig = SQL_TYPE_XML_LOCATOR + %rem(gDsSqlVar.SqlTypeOrig:2);
      gDsSqlVar.SqlLen = %size(BlobLocator); 
      gDsSqlVar.SqlBytes = gDsSqlVar.SqlLen; 
      pDsSqlVar.SqlType = gDsSqlVar.SqlTypeOrig;
      ////pDsSqlVar.SqlLen = gDsSqlVar.SqlLen;
      ////pDsSqlVar2.SqlLongL = 0;
      
  endsl;
  
  if pinSqlVarOccur = 2;
    return 0;
  endif;
    
  // SQLVAR 3  
  pPtSqlVar2 = %Addr(pDsResultDa.Sql_Var(1)) + %size(SQLVAR2) * (pinFields*2 + pInColIndex-1); 

  if pDsSqlVar2.SqlTNameLn > 0; 
    gDsSqlVar.SqlText = %subst(pDsSqlVar2.SqlTName:1:pDsSqlVar2.SqlTNameLn);
  endif;

  return 0;      
       
end-proc SqlFillSqlVar;
//---------------------------------------------------------------*
//  SqlGetSqlVar
//---------------------------------------------------------------*
dcl-proc SqlGetSqlVar;
  dcl-pi *N int(10);
    pInResultSet int(10) const;
    pInColIndex int(10) const;
  end-pi;
       
  //dcl-s inInd int(5) based(pDsSqlVar.SqlInd);

  gPtResultSet = OoRObjectGet(s#prog:pInResultSet);
  if gPtResultSet = *Null;
    // todo message
    return 0;
  endif;

  if pInColIndex > gDsResultSet.inFields;
    return -1;
  endif;  
  
  gPtSqlVar = gDsResultSet.ptSqlVars + %size(gDsSqlVar) * (pInColIndex-1); 

  //gDsSqlVar.SqlData = pDsSqlVar.SqlData;
  //if pDsSqlVar.SqlInd <> *Null; 
  //  gDsSqlVar.SqlIndVal = inInd;
  //  gDsSqlVar.SqlIsNull = (inInd = -1);
  //  gDsSqlVar.SqlHasError = (inInd < -1);
  //endif;  

  return 0;      
       
end-proc SqlGetSqlVar;
